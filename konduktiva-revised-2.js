//------------------------------------------------------------------------------
//-- konduktiva-revised.js
//-- Wed Feb  2 07:28:37 PM JST 2022
// license not yet decided; please do not distribute yet.
//------------------------------------------------------------------------------

const R = await import('ramda')
const performance = await import('perf_hooks');
performance = performance.performance
let TaskTimerDefault = await import('tasktimer');
const {TaskTimer} = TaskTimerDefault.default
// const {TaskTimer} = require('tasktimer')
//const easymidi = require('easymidi');
const fs = await import('fs')
const path = await import('path')
let oscDefault = await import("osc");
const osc = oscDefault.default
const v8 = await import('v8');
const A = await import('array-toolkit')
// const A = await import('./github-array-toolkit-package/array-toolkit/array-toolkit.mjs')

/** 
  * Returns the current year, month, and day (yyMMdd)
  * @example console.log(ymd()) //'230821'
*/
function ymd () {
    let dateObj = new Date();
    let y = (""+dateObj.getFullYear()).slice(2);
    let m = "" + (dateObj.getMonth() + 1);
    if (m.length < 2) {m = "0"+m} else {m = "" + m}
    let d = dateObj.getDate();
    if (d.length < 2) {d = "0"+d} else {d = "" + d}
    return y+m+d
}

const structuredClone = obj => {
      return v8.deserialize(v8.serialize(obj));
};


//--------------------------------------------------------------------------
// utility

/**
  * Adds the input of the function to a file called test.log
  * @param {*} x - The item to add to test.log file.
  * @example
  * console.log(addLog([0, 1, 2, 3])) //will add: 0,1,2,3
  * console.log(addLog('hi')) //will add: hi
*/
function addLog (x) {
    let d = new Date ();
    fs.appendFile('test.log', 
//"--------------------------------------------------------------------------" 
//       + "\nbegin: "+d+"\n\n"+x+"\n" +
         "\n"+x+"\n" +
//       + "\n-- end. " + d + "\n" +
"--------------------------------------------------------------------------" 
       + "\n"
        , function (err) { if (err) throw err; /*console.log('Saved!');*/ })
}

/**
 * Adds the item and the item type to the file test.log
 * @param {*} x - Item to add.
 * @example 
 * console.log(addLog2([0, 1, 2, 3])) //will add: [ 0, 1, 2, 3 ]
 * console.log(addLog2('hi')) //will add: 'hi'
*/
function addLog2 (x) {addLog(util.inspect(x, {maxArrayLength: null, depth: null}))}

/**
  * Outputs how long since the nodejs session has started in seconds.
  * @requires perf_hooks
  * @see {@link https://nodejs.org/api/perf_hooks.html#performancenow} to see how performance.now() works.
  * @example now() //23.817596345998346
*/
function now () {
    return 0.001 * performance.now()
}

/**
  * Returns a whole number between the min and max values.
  * @param {number} min - Minimum amount the random number can be.
  * @param {number} max - Maximum amount the random number can be.
  * @example console.log(randomRangeInt(0, 10)) //9
*/
function randomRangeInt (min, max) {
    return Math.floor(randomRange(min, max))
}

/**
  * A lerp/linear interpolation function finding a value that is between two other values by a certain fraction, which is represented by the s parameter in your function (partially generated by chatgpt)
  * @see {@link https://en.wikipedia.org/wiki/Linear_interpolation}
  * @param {number} y1
  * @param {number} y2
  * @param {number} s
  * @example console.log(lerpValues(10, 20, 30)) //310
*/
function lerpValues (y1, y2, s) {return y1 + s * (y2 - y1)}

/**
  * Returns an array of numbers of a specific length that are always equally different in amount. This function calculates a specific number of intervals to get from start number to stop number.
  * @param {number} start - Number to start from.
  * @param {number} stop - Number to stop at.
  * @param {number} steps - The number of intervals/steps to take to get from start to stop
  * @example
  * console.log(lerpedRange(0, 10, 4)) //[ 0, 5, 10 ]
  * console.log(lerpedRange(0, 10, 7)) //[ 0, 2, 4, 6.000000000000001, 8, 10 ]
*/
function lerpedRange (start, stop, steps) {
    let stepArray = A.integerArray(0,steps-1);
    let stepSize = 1/(stepArray.length-1);
    let scalars = stepArray.map(x => x * stepSize);
    return scalars.map(x => lerpValues (start, stop, x))
}

/** Class for representing a point. */
class Point {
  /**
    * Creates the point.
    * @param {*} x - X value.
    * @param {*} y - Y value.
  */
  constructor(x,y) {
    this.x = x;
    this.y = y;
  }
  /**
    * Moves the point.
    * @param {*} xDistance - Item that gets added to the x value.
    * @param {*} yDistance - Item that gets added to the y value.
  */
  move(xDistance, yDistance) {
    return new Point(this.x + xDistance, this.y + yDistance)
  }
  /**
    * Moves the point by angle and distance.
    * @param {number} angle - Angle point should rotated by.
    * @param {number} distance - The amoun the point should be moved along the angle.
  */
  moveByAngle (angle, distance) {
            let r = angle * Math.PI / 180;
            return new Point(this.x + distance*Math.sin(r), this.y + distance*Math.cos(r))
            }    
}

/**
  * Function that calculates slope intercept. It returns the an object with the equation stored as a function and as a string.
  * @param {Point} p1 - First Point.
  * @param {Point} p2 - Second Point.
*/
function linearFunctionFromPoints(p1,p2) {
    let rise = p2.y - p1.y;
    let run = p2.x - p1.x;
    let slope = rise/run; 
    // y = mx + b
    let b = p1.y - (slope * p1.x);
    //console.log('the linear function is: y = ' + slope + 'x + ' + b);
    return {func: (x => (x * slope) + b), note: 'y = ' + slope + 'x + ' + b}
}

/**
  * Calculates all the slope intercepts in an array of points.
  * @param {array} pointArray - The array of Points to sort through.
  * @example console.log(linearFunctionArrayFromPoints([new Point(0, 10), new Point(5, 20), new Point(10, 30)])) //[ { func: [Function: func], note: 'y = 2x + 10' }, { func: [Function: func], note: 'y = 2x + 10' } ]
*/
function linearFunctionArrayFromPoints (pointArray) {
    return A.safeSplice(pointArray, 1, 0).map((x, i) =>{
        return linearFunctionFromPoints(pointArray[i],pointArray[i+1])
    })
}
//partially helped by chatgpt

/**
  * Calculates all the slope intercepts in an array of points and returns them in form of a QuantizedMap. The keyspan will be the final X value. The keys will will be all the X values in the array. 
  * @param {array} pointArray - The array of Points to sort through.
  * @example
  * linearFunctionQuantizedMap([new Point(0, 10), new Point(5, 20), new Point(10, 30)]) //QuantizedMap { keyspan: 10, keys: [ 0, 5, 10 ], values: [ { func: [Function: func], note: 'y = 2x + 10' }, { func: [Function: func], note: 'y = 2x + 10' } ] }
*/
function linearFunctionQuantizedMap (pointArray) {
    let times = pointArray.map(t => t.x);
    return new QuantizedMap(times[times.length-1], times, linearFunctionArrayFromPoints(pointArray)) 
}

// knuth shuffle from https://stackoverflow.com/questions/2450954/how-to-randomize-shuffle-a-javascript-array 

//------------------------------------------------------------------------------
// lsystem functions

function parseItem (input, rules) {
    if (Object.keys(rules).includes(input)) {
        return rules[input]}
    else {
        return input
    }
}
// let parseItem = (input,rules) => { if (Object.keys(rules).includes(input)) {return rules[input]} else {return input}}

// let parseString = (inputString,rules) => inputString.split("").map(x => parseItem(x,rules)).join().replace(/,/g,"")
function parseString (inputString, rules) {
    return inputString.split("").map(x => parseItem(x,rules)).join().replace(/,/g,"")
}

function lsystem (inputString,rules,generations) {
        if (generations > 0) {return lsystem (parseString(inputString,rules),rules,generations-1)}
        else {return inputString}
}

function rewriteString (inputString, stringMap) {
    let splitString = inputString.split('');
    return splitString.map(c => stringMap[c])
}

// uses code from Javier Conde https://stackoverflow.com/questions/34929094/how-can-i-get-all-possible-characters-in-javascript

/**
  * Returns an array of all the English alphabets.
*/
function getAllAlphabets() {
  return Array.from({ length: 26 * 2 }, (_, index) => {
    let charCode = index < 26 ? 97 + index : 65 + index - 26;
    return String.fromCharCode(charCode);
  });
}
//Generated by Chatgpt:

/**
  * Assigns each item of an array a letter of the English alphabet.
  * @param {array} inputArray - Array of things to assign letter to.
  * @example console.log(randomCharacterMapFromArray([0, 1, 2, 10])) //{ a: 1, b: 0, c: 2, d: 10 }
*/
function randomCharacterMapFromArray (inputArray) {
    let allChars = getAllAlphabets();
    if (allChars.length < inputArray.length) {return "error: inputArray is longer than array of alphabetic characters"};
    let outputMap = {};
    charactersToUse = A.takeN(allChars,inputArray.length);
    let shuffled = A.shuffle(inputArray);
    charactersToUse.forEach((x,i) => {outputMap[x] = shuffled[i]})
    return outputMap
}

/**
  * Assigns an item of one array to one item of the other array.
  * @param {array} keyArray - Array of keys.
  * @param {array} valueArray - Array of values.
  * @example console.log(randomMap(['a', 'b', 'c', 'd'], [0, 1, 2, 3])) //{ a: 1, b: 3, c: 2, d: 0 }
*/
function randomMap (keyArray, valueArray) {
    if (keyArray.length < valueArray.length) {return "error: key array is longer than value array"};
    let outputMap = {};
    charactersToUse = A.takeN(keyArray,valueArray.length);
    let shuffled = A.shuffle(valueArray);
    charactersToUse.forEach((x,i) => {outputMap[x] = shuffled[i]})
    return outputMap
}

function rulesGenerator (inputPool, maxRuleLength) {
    let ruleLengths = A.pickN (inputPool.length, A.linearArray(1,1,maxRuleLength));
    return (ruleLengths.map(x => A.pickN(x, inputPool) ) )
}

function variousLsystems(baseName,n,patternLength,rules,generations,replacementValues,inputString) {
    let replacements = A.buildArray(n, x => randomMap(getAllAlphabets(), replacementValues));
    let thisL = lsystem (inputString, rules, generations);
    let lsystems = replacements.map(x => A.loopTo(patternLength,rewriteString(thisL,x)))
    let names = A.buildArray(n, i => baseName+i);
    let outputMap = {};
    names.forEach((x,i) => outputMap[x] = lsystems[i]);
    return outputMap
}

//--------------------------------------------------------------------------
//midi actions

/**
  * Turns off all notes on a specific channel for the output.
  * @param {number} channelNum - Channel to send off to.
*/
function allNotesOff(channelNum) {
  Array.from({ length: 128 }, (_, noteNumber) => {
    output.send('noteoff', {
      note: noteNumber,
      velocity: 0,
      channel: channelNum,
    });
  });
}
//partially generated by chatgpt

//--------------------------------------------------------------------------
// the easiest way to make a rhythm

/**
  * Helps create a simpel rhythm in Konduktiva.
  * @param env - Musical Environment
  * @param {string} rhythmName - The name of the new rhythm.
  * @param {array}
*/
function simpleRhythm (env, rhythmName, deltas) {
    env.rhythmMaps[rhythmName] = new QuantizedMap(1,[1],[new QuantizedMap(A.sum(deltas),[0].concat(A.runningSum(0,deltas)),deltas)])
    return rhythmName
}

//--------------------------------------------------------------------------
// rhythm pattern with density

// increase density

// revise these so that the algorithm is swappable

function increaseDensity (minVal,ratio,inputArray) {
    let max = A.getMaxIndex(inputArray);
    if (max[0][1] <= minVal) {console.log("max is already at minVal");return inputArray} 
    else {
        let toIncrease = A.pick(max);
        console.log("this is the max: " + toIncrease);
        let outputA = inputArray.slice(0,toIncrease[0]);
        console.log("this is outputA: " + outputA);
        let outputB = inputArray.slice(toIncrease[0]+1);
        let newVals = [toIncrease[1]*ratio,toIncrease[1] - (toIncrease[1]*ratio)];
        return outputA.concat(newVals.concat(outputB))
    }
}

function decreaseDensity (inputArray) {
    let target = (A.pick(A.integerArray(0,inputArray.length - 2)));
    let outputA = inputArray.slice(0,target);
    let outputB = [inputArray[target] + inputArray[target+1]].concat(inputArray.slice(target+2))
    return outputA.concat(outputB)
}

function recursiveIncreaseDensity (minVal, ratios, stack) {
    if (A.getMaxIndex(stack[0])[0][1] > minVal) {
        let r = A.pick(ratios);
        let addToStack = increaseDensity(minVal,r,stack[0]);
        return recursiveIncreaseDensity(minVal, ratios, [addToStack].concat(stack))
    }
    return stack
}

function recursiveDecreaseDensity (stack) {
   console.log(stack);
   let targetArray = stack[(stack.length -1)];
   if (targetArray.length > 1) {
       console.log("this is the target array");
       return recursiveDecreaseDensity(stack.concat([decreaseDensity(stack[stack.length -1])]))
   }
    return stack
}

function densityStack (minVal, ratios, inputArray) {
    return recursiveDecreaseDensity(recursiveIncreaseDensity(minVal, ratios, [inputArray]))
}

// musical time

function deltaToAbsolute (inputArray) {
    let output = [0];
    inputArray.forEach((e,i) => output.push(output[i]+e));
    return [R.last(output),R.init(output)]
}

function absoluteToDelta (inputArray) {
    let output = [];
    [head, ...tail] = inputArray;
    tail.forEach((e,i) => output.push(e - inputArray[i]))
    return output
}

function densityFromDeltas (inputDeltas) {
    return inputDeltas.length/A.sum(inputDeltas)
}

//  keyspan is max value, keys is an array of absolutes (increasing values), values is an array of anything of the same length as keys 

class QuantizedMap {
    constructor(limitValue,keys,vals) {
        this.keyspan = limitValue;
        this.keys = keys;
        this.values = vals;
        }
    wrapLookup(time) {
        let lookupTime = time%this.keyspan;
        let filteredTime = this.keys.filter(x => x <= lookupTime);
        if (filteredTime[0] == undefined) {filteredTime = [0]};
        return this.values[(filteredTime.length - 1)]
        }
    floorLookup(time) {
        let lookupTime = time;
        let output = undefined;
        if (lookupTime >= this.keyspan)
            {output = this.values[this.values.length - 1]}
        else if (lookupTime < this.keys[0])
            {output = this.values[0]}
        else {
            let filteredTime = this.keys.filter(x => x <= lookupTime);
            if (filteredTime[0] == undefined) {filteredTime = [0]};
            output = this.values[(filteredTime.length - 1)]
            }
        return output
        }
    nearestLookup (time) {
        let lookupTime = time;
        let output = undefined;
        if (lookupTime >= this.keys[this.keys.length - 1])
            {output = this.values[this.values.length - 1]}
        else if (lookupTime < this.keys[0])
            {output = this.values[0]}
        else {
            let filteredTime = this.keys.filter(x => x <= lookupTime);
            if (filteredTime[0] == undefined) {filteredTime = [0]};
            let lower = filteredTime[filteredTime.length - 1];
            let higher = this.keys[filteredTime.length]
            if ((lookupTime - lower) < (higher - lookupTime)) 
                {output = this.values[(filteredTime.length - 1)]}
            else {output = this.values[(filteredTime.length)]}
            }
        return output
        }
}

function whichWrapKey(qm, time) {
    let lookupTime = time%qm.keyspan;
    let filteredTime = qm.keys.filter(x => x <= lookupTime);
    if (filteredTime[0] == undefined) {filteredTime = [0]};
    return filteredTime[filteredTime.length - 1]
    }

// time needs to be remaindered by the keyspan!
function calculateDensity (env, playerName, time) {
    let dGraphs = env.currentDensityGraphs.map(x => env.densityGraphs[x]);
    //console.log(dGraphs);
    let densityFuncMaps = dGraphs.map((x) => {
        if (Object.keys(x).includes(playerName)) {return x[playerName]}
        else if (Object.keys(x).includes('default')) {return x.default}
        // this has to be a QuantizedMap
        // else {return x => 1}
        else {return linearFunctionQuantizedMap([new Point(0,1), new Point (1,1)]) }
    });
    let densityFuncs = densityFuncMaps.map(x => [(x.floorLookup(time%x.keyspan)).func,x.keyspan])
    let densities = densityFuncs.map(x => x[0](time%x[1]))
    return A.mean(densities)
}

//Might be wrong don't know how to test.
function makeRhythmMap (minIOI, ratios, deltas) {
    let stack = densityStack(minIOI,ratios,deltas);
    let absolutes = stack.map(deltaToAbsolute);
    let densities = stack.map(densityFromDeltas)
    let rows = stack.map((x, i) => {
        return new QuantizedMap(absolutes[i][0],absolutes[i][1],stack[i])
    })
    return new QuantizedMap(densities[0],R.reverse(densities),R.reverse(rows))
}

//------------------------------------------------------------------------------
// stochastic rhythmMap functions

function generateSeed (onsetValues, seedLengths) {
    let seedLength = A.pick(seedLengths);
    return A.pickN(seedLength, onsetValues)
}

function generatePhrase (onsetValues, seedLengths, noOfSeeds, phraseLength) {
    let seeds = A.buildArray(noOfSeeds, x => generateSeed(onsetValues, seedLengths));
    return A.takeTo(phraseLength,R.flatten(seeds))
}

function generateAndAddRhythms(env, n, baseName, onsetValues, minIOI, ratios, seedLengths, noOfSeeds, phraseLength) {
    let names = A.buildArray(n, x => baseName + x);
    let rhythms = A.buildArray(n, x => generatePhrase(onsetValues,seedLengths,noOfSeeds,phraseLength));
    let rhythmMaps = rhythms.map(r => makeRhythmMap(minIOI, ratios, r));
    names.forEach((name,i) => {return env.rhythmMaps[name] = rhythmMaps[i]})
}


//------------------------------------------------------------------------------
// getting IOIs

function getRemainingDelta (densityMap, density, beat) {
    let wrappedBeat = beat % densityMap.floorLookup(density).keyspan;
    let currentDelta = densityMap.floorLookup(density).floorLookup(wrappedBeat);
    let currentKey = whichWrapKey(densityMap.floorLookup(density),beat);
    let remainingDelta = currentDelta - (wrappedBeat - currentKey);
    return remainingDelta
}

function getNextOnset (densityMap, density, beat) {
    return beat + getRemainingDelta(densityMap, density, beat)
    }

function getDelta (densityMap, density, beat) {
    return densityMap.floorLookup(density).wrapLookup(beat)
}

function getNextOnsetFromRhythmMap (densityMap, density, beat) {
    return beat + getRemainingDelta(densityMap, density, beat)
    }

function getIOI (env, player, beat) {
    let density = calculateDensity (env, player, beat);
    let rhythmMap = env.rhythmMaps[env.players[player].rhythmMap]
    let onset = getNextOnsetFromRhythmMap(rhythmMap,density,beat)
    return onset
}

// write a generalized version of this that can accept any IOIFunc

function getNextOnsets (densityMap, density, beat, limitBeat, output) {
    if (beat > limitBeat) {
        return output
    }
    else {
        // replace getNextOnset with generalized IOIFunc here?
        let nextOnset = getNextOnset(densityMap, density, beat);
        output = output.concat(nextOnset)
        return getNextOnsets (densityMap, density, beat+nextOnset, limitBeat, output)
    }
}

function getNextOnsets2 (ioiFunc, beat, limitBeat, output) {
    if (beat > limitBeat) {
        return output
    }
    else {
        // replace getNextOnset with generalized IOIFunc here?
        let nextOnset = ioiFunc(beat);
        output = output.concat(nextOnset)
        return getNextOnsets2 (ioiFunc, beat+nextOnset, limitBeat, output)
    }
}

function getNextOnsets3 (ioiFunc, player, beat, limitBeat, output) {
    if (beat > limitBeat) {
        return output
    }
    else {
        // replace getNextOnset with generalized IOIFunc here?
        let nextOnset = ioiFunc(player, beat);
        output = output.concat(nextOnset)
        return getNextOnsets3 (ioiFunc, player, beat+nextOnset, limitBeat, output)
    }
}

// probability of masking
function mask (player, maskMap, beat, probability) {
    let maskVal = maskMap.wrapLookup(beat);
    if (maskVal == true && (Math.random() < probability)) {maskVal = true} else {maskVal = false};
    //if (maskVal == true) {addLog(''+player+' function was masked at beat '+beat+'.')}
    return maskVal
}

class MusicalEnvironment {
    constructor (){
        this.players = {};
        this.actions = {};
        this.IOIs = {};
        this.densityGraphs = {};
        this.rhythmMaps = {};
        this.maskMaps = {};
        this.superDirtPath = undefined;
        this.samples = undefined;
        this.sampleKits = {};
        this.samplePatterns = {};
        this.samplePatternCount = 0;
        this.samplePatternStore = {};
        this.currentDensityGraphs = [];
        this.currentBeatsPerMeasure = 4;
        this.currentTempo = 120;
        this.beatOfChangeToCurrentTempo = undefined;
        this.timeOfChangeToCurrentTempo = undefined;
        this.scheduler = new TaskTimer(20);
        this.lookahead = 0.1;
        this.scheduledPlayers = [];
        this.root = "A";
    }
    currentBeat () {
        let elapsed = now() - this.timeOfChangeToCurrentTempo;
        return timeToBeats(this.currentTempo, elapsed) + this.beatOfChangeToCurrentTempo
    }
    changeTempo(tempo) {
        this.beatOfChangeToCurrentTempo = this.currentBeat ();
        this.timeOfChangeToCurrentTempo = now();
        // this.beatOfChangeToCurrentTempo = beatOfChangeToCurrentTempo + timeToBeats(timeSinceTempoChange())
        console.log("TEMPO CHANGE! time: " + this.timeOfChangeToCurrentTempo + "; beat: " + this.beatOfChangeToCurrentTempo);
        this.currentTempo = tempo;
    }
    getAction (player) {
        // console.log("running action for player " + player + " at beat " + this.currentBeat())
        return this.actions[(this.players[player].action)];
    }
    getIOIFunc (player) {
        return this.IOIs[(this.players[player].IOIFunc)];
    }

    scheduleEvents (player) {
        //console.log("scheduling " + player);
        let ioiFunc = this.getIOIFunc (player);
        let onsets = getNextOnsets3(ioiFunc,player, this.currentBeat(), this.currentBeat() + timeToBeats(this.currentTempo,this.lookahead),[]);
        let onsetsAfterLastScheduled = onsets.filter(x => x > this.players[player].lastScheduledTime);
        if (player.verbose == true) {
        console.log(" -------------------------------------------------------------------------- " );
        console.log("current beat: " + this.currentBeat());
        console.log("onsets after last scheduled: " + onsetsAfterLastScheduled)};
        if (onsetsAfterLastScheduled[0] !== undefined) {
            this.players[player].lastScheduledTime = R.last(onsetsAfterLastScheduled);
            // run the masking here
            //let currentMaskMap = this.maskMaps[this.players[player].maskMap];
            //let unmaskedOnsets = onsetsAfterLastScheduled.filter(t => (mask(player,currentMaskMap,(t),1)) != true);
            let unmaskedOnsets = onsetsAfterLastScheduled;
            let times = unmaskedOnsets.map(x => beatsToTime(this.currentTempo, x - (this.currentBeat())));
            if (player.verbose == true) { console.log("these are the times for events of player " + player + ": " + times)};
            //if (player == 'kick') {console.log(unmaskedOnsets)}
            times.forEach(
                (t,i) => {
                    setTimeout(x => (this.getAction(player))(player,unmaskedOnsets[i]),
                    Math.max(1000 * (t - now()),0))
                }
            );
        };
        if (player.verbose == true) { console.log("last scheduled time: " + this.lastScheduledTime)}
    }

    startScheduler () {
        this.timeOfChangeToCurrentTempo = now();
        this.beatOfChangeToCurrentTempo = 0;
        this.scheduler.start()
    }
    stopScheduler () {
        this.timeOfChangeToCurrentTempo = undefined; 
        this.beatOfChangeToCurrentTempo = undefined;
        //this.lastScheduledTime = 0;
        this.scheduler.stop()
    }
    play (player) {
        if (this.players[player].status == "playing") 
            {console.log("Player " + this.players[player].name + " is already playing!")}
        else {
            this.scheduledPlayers = this.scheduledPlayers.concat(player);
            this.players[player].status = "playing";
            this.players[player].startTime = now();
        }
    }
    stop (player) {
        if (this.players[player].status == "stopped") 
            {console.log("Player " + this.players[player].name + " is not playing!")}
        else {
//             this.scheduledPlayers = A.removeItem(this.scheduledPlayers,player)
            this.scheduledPlayers = A.removeAllInstance(this.scheduledPlayers,player)
            this.players[player].status = "stopped";
            this.players[player].startTime = undefined;
            this.players[player].lastScheduledTime = 0;
        }
    }
    allPlayers () {
        return Object.keys(this.players)
    }
    allPlayerStatus () {
        Object.keys(this.players).forEach(x => console.log(x,this.players[x].status))
        return Object.keys(this.players).map(x => [x,this.players[x].status])
    }
    playingPlayers () {
       let ps = this.allPlayerStatus ();
       let withStatus = ps.filter(p => p[1] == 'playing')
       return withStatus.map(p => p[0])
    }
    playN (ps) {
        ps.forEach(p => this.play(p))
    }
    stopN (ps) {
        ps.forEach(p => this.stop(p))
    }
    playAll () {
        this.allPlayers().forEach(p => this.play(p))
    }
    stopAll () {
        this.allPlayers().forEach(p => this.stop(p))
    }
    solo (ps) {
        this.stopN(this.allPlayers().filter(p => !A.matchesOneOf(ps,p)))
    }
    togglePlayer (p) {
       if (this.players[p].status == 'playing') {this.stop(p)} else {this.play(p)}
    }
}

function setupScheduler (musicalEnv) {
        musicalEnv.scheduler.add([
            {
                id: 'schedulePlayers',       // unique ID of the task
                //tickInterval: musicalEnv.lookahead * 1000/20,    
                tickInterval: 1,    
                totalRuns: 0,      // (set to 0 for unlimited times)
                callback(task) {
                    // code to be executed on each run
                    //console.log("scheduled players " + musicalEnv.scheduledPlayers);
                    musicalEnv.scheduledPlayers.map(p => musicalEnv.scheduleEvents(p))
                }
            }
        ]);
    }

class Player {
    constructor(name) {
        this.name = name;
        this.status = "stopped";
        this.verbose = false;
        this.IOIFunc = "default";
        this.rhythmMap = "default";
        this.maskMap = "default";
        this.density = 1;
        this.densityGraph = "defaultTechno";
        this.action = "default";
        this.velocityMap = "default";
        this.samplePattern = undefined;
        this.cut = 0;
        this.counter = 0;
        this.interrupt = "default";
        this.startTime = undefined;
        this.lastScheduledTime = 0;
    }
}

function beatsToTime (tempo, beats) {
    let beatsPerSecond = (tempo/60);
    return beats/beatsPerSecond
}

function timeToBeats (tempo, time) {
    let beatsPerSecond = (tempo/60);
    return time * beatsPerSecond
}


//--------------------------------------------------------------------------

function setupSuperDirtPlayer (env, playerName) {
        env.players[playerName] = new Player(playerName);
        env.players[playerName].maskMap = 'default'
        env.players[playerName].samplePattern = playerName;
        env.players[playerName].action = "superDirt";
        return playerName
}

function simpleSamplePattern (env, playerName, sampleName, sampleIndex) {
        addSamplePattern (e, playerName, new QuantizedMap(4,[0],[{name: sampleName, index: sampleIndex}]));
        return playerName
}

class RhythmPattern {
        constructor (n,l,i,b) {
                    this.patternName = n;
                    this.patternLength = l;
                    this.IOIs = i;
                    this.bools = b;
                    return this
                }
        addToPlayer (env, playerName) {
            this.playerName = playerName
                    simpleRhythm (env, this.patternName, A.loopTo (this.patternLength,this.IOIs))
                    env.players[this.playerName].rhythmMap = this.patternName;
                    let mask = A.flipBooleans(this.bools);
                    env.players[this.playerName].maskMap = this.patternName;
                    env.maskMaps[this.patternName] = new QuantizedMap(this.patternLength,[0].concat(A.runningSum(0,this.IOIs)),mask)
                }
        add (env, playerName) {
            this.playerName = playerName
                    simpleRhythm (env, this.patternName, A.loopTo (this.patternLength,this.IOIs))
                    let mask = A.flipBooleans(this.bools);
                    env.maskMaps[this.patternName] = new QuantizedMap(this.patternLength,[0].concat(A.runningSum(0,this.IOIs)),mask)
                }
}

function createRhythmPattern (argObj) {
    let pattern = new RhythmPattern (
                        argObj.voice,
                        argObj.patternName,
                        argObj.patternLength,
                        argObj.IOIs,
                        argObj.bools)
    return pattern
}

function simpleRhythmPattern (env, rhythmPatternArgObj) {
    let pattern = createRhythmPattern (rhythmPatternArgObj);
    pattern.add(env)
    return pattern.patternName
}

